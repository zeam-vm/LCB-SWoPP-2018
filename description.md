# はじめに

Node.jsでは，コールバックを用いてI/Oを非同期的に扱ってノンプリエンプティブなマルチタスクにする機構，Nodeプログラミングモデルが備わっている\cite{Node}．これにより，ウェブサーバーのメモリ使用量を格段に減らすことができ，同時セッション最大数やレイテンシが改善される\cite{NodeBenchmarks}．

もしNodeプログラミングモデルと同様の機構を，Javascriptよりパフォーマンスの良いプログラミング言語で実装したならば，ウェブサーバーの性能を格段に向上させることができる．そこで，我々は \Cpp とElixir \cite{Elixir} の2つのプログラミング言語を選んで実装を試みた． \Cpp を選んだのは，RFIDのような極端に小規模で消費電力の少ないような電子回路を用いてIoTデバイスを構築することを意図し，できるだけ小さなメモリ容量で実現でき，かつ \Cpp 11 はNodeプログラミングモデルの実現に必要な匿名関数を備えているからである．Elixirを選んだのは，Elixirで書かれたウェブサーバーフレームワークであるPhoenixを用いることで，極めてレスポンス性の高いウェブサーバーを構築できる \cite{Elixir16} からである．

我々の \Cpp への実装を Zackernel と称し，Elixir への実装を軽量コールバックスレッドと称している．これらを組合わせることで，世界中にばらまいた膨大な数のRFIDによる極小IoTデバイスと，それらから随時リクエストを受け付けるIoTサーバーからなるIoTシステムを構築することができる．

本報告では，Zackernel と軽量コールバックスレッドをどのように実装したのかを紹介し，メモリ消費量に焦点を当てて評価を行なう．

本報告のこの後の構成は次のとおりである．第2章では着想の元となったNodeプログラミングモデルについて紹介する．第3章ではZackernelの設計と実装を，第4章では軽量コールバックスレッドの設計と実装をそれぞれ示す．第5章ではメモリ消費量の評価を行う．最後に第6章でまとめと将来課題について述べる．

# Nodeプログラミングモデル

Nodeプログラミングモデル\cite{Node}

# Zackernel

# 軽量コールバックスレッド


# 評価

実験で用いた環境を\tabref{tab:environment}に示す．

\begin{table}[t]
\centering
\caption{実行環境}
\ecaption{Runtime Environment}
\label{tab:environment}
\begin{tabular}{l|l}
                       & Mac Pro (Mid 2010)     \\ \hline
OS                     & macOS Sierra 10.12.6   \\
Elixir                 & 1.6.1 (OTP 20.3.6)     \\
\end{tabular}
\end{table}

Zackernelのメモリ消費量を \Cpp 11スレッドを用いた場合と比較する評価実験を行なった．C言語によるmacOSでのメモリ消費量の測定には `mach/mach.h` に定義している `task_basic_info` 構造体を用いて `virtual_size` で示される仮想メモリサイズを用いた．この値はバイト単位で表されるが，実際にはページ単位でメモリを扱うので，ページサイズの倍数値になる．そのため，ページサイズより小さなメモリ量の変化は測定結果に現れない．また，何回か実行するとばらつきを持った測定値となったので，繰返し測定して最初に3回同じ測定値になった場合の値を採用した．作成するスレッドの数は1,10,100,1000,2000,5000,10000,20000,50000の9通りで測定した．これらの測定結果を最小2乗法で傾きを求めることで，1スレッドあたりの使用メモリ量を測定した．

Zackernelと \Cpp 11スレッドのメモリ消費量を比較した実験結果を\tabref{tab:resultsZ}に示す．それぞれの相関係数は，Zackernelで0.8396， \Cpp 11スレッドで0.99993であった． \Cpp 11スレッドでは良好な結果が得られたと判断できるが，Zackernel ではスレッド数が小さい場合にページサイズより小さなメモリ変化しかなかったので測定値に現れず，結果的に相関係数の絶対値が小さくなった．Zackernel では1スレッドあたり204バイト， \Cpp 11スレッドでは1スレッドあたり約546KB消費していることがわかった．すなわち，Zackernel は \Cpp 11スレッドの約2,700分の1のメモリ消費量である．
 

\begin{table}[tb]
\centering
\caption{実験結果: Zackernelと \Cpp 11スレッドのメモリ消費量の比較(表)}
\ecaption{Results: Table of Comparison of Memory Size of Zackernel and \Cpp 11 Thread}
\label{tab:resultsZ}
\begin{tabular}{l|
>{\columncolor[HTML]{C0C0C0}}l
l}
Num. of Tasks & Zackernel    & \Cpp 11 Thread \\ \hline
1             & 0            & 536576     \\
10            & 0            & 5365760    \\
100           & 0            & 53657600   \\
1000          & 2097152      & 537624576  \\
2000          & 2097152      & 1094123520 \\
5000          & 4194304      & N/A        \\
10000         & 5242880      & N/A        \\
20000         & 7340032      & N/A        \\
50000         & 10485760     & N/A          
\end{tabular}
\end{table}


また軽量コールバックスレッドのメモリ消費量を，Elixirプロセスを用いた場合と比較する評価実験を行なった．Elixir にはメモリ消費量を測定するために `:erlang.memory` という関数が用意されている．この関数は全体のメモリ量やプロセスで使用しているメモリ量などを集計することができる．本研究では，軽量コールバックスレッドもしくはElixirプロセスを一定数新規作成する前後の全体のメモリ量の変化を計測した．作成するスレッドもしくはプロセスの数は100, 1000, 2000, 5000, 10000の5通りで測定した．これらの測定結果を最小2乗法で傾きを求めることで，1スレッドもしくは1プロセスあたりの使用メモリ量を測定した．

軽量コールバックスレッドとElixirプロセスのメモリ消費量を比較した実験結果を\tabref{tab:results}と\figref{fig:results}に示す．それぞれの相関係数は軽量コールバックスレッドの場合で0.99284，Elixirプロセスの場合で0.99998であったので，実験結果は良好であったと考えられる．傾きより，軽量コールバックスレッドの場合で1スレッドあたり1332バイト，Elixirプロセスの場合で1プロセスあたり2835バイト消費していることがわかった．すなわち，軽量コールバックスレッドはプロセスの約半分のメモリ消費量である．

これらの1スレッド/プロセスあたりのメモリ消費量を比較すると，Zackernel が204バイトと最も少なく，軽量コールバックスレッドが1332バイト，Elixirプロセスが2835バイトと続き， \Cpp 11 スレッドが約546KBとなる．処理系レベルから設計を見直すことで，軽量コールバックスレッドをZackernel並みのメモリ消費量に抑える最適化を施せる余地があるのかもしれない．

\begin{table}[tb]
\centering
\caption{実験結果: 軽量コールバックスレッドとプロセスのメモリ消費量の比較(表)}
\ecaption{Results: Table of Comparison of Memory Size of Light-weight Callback Threads and Processes}
\label{tab:results}
\begin{tabular}{r
>{\columncolor[HTML]{C0C0C0}}r r}
\multicolumn{1}{l}{Num. of Tasks} & \multicolumn{1}{l}{\cellcolor[HTML]{C0C0C0}CallBack (bytes)} & \multicolumn{1}{l}{Process (bytes)} \\
100                                             & 76144                                                        & 358848                              \\
1000                                            & 881656                                                       & 2877360                             \\
2000                                            & 1496296                                                      & 5636232                             \\
5000                                            & 5734120                                                      & 14160616                            \\
10000                                           & 13004640                                                     & 28402248                           
\end{tabular}
\end{table}

# まとめと将来課題

本研究ではNodeプログラミングモデルと同様の機構を \Cpp と Elixir で実装，それぞれ Zackernel，軽量コールバックスレッドと呼称した．

これらと従来のプロセス/スレッドとの1プロセス/スレッドあたりのメモリ消費量を比較する評価実験を行なった．その結果，Zackernel は1スレッドあたり204バイトと最も少なく，軽量コールバックスレッドが1スレッドあたり1332バイト，Elixirプロセスが1プロセスあたり2835バイト，\Cpp 11スレッドが1スレッドあたり約546KBであった．

将来課題としては，まずそれぞれの方法でコンテキストスイッチにどのくらいの時間を要するのかを測定することが挙げられる．コンテキストスイッチに要する時間は，マルチプロセス／マルチスレッドのシステム実装を評価する際に，1スレッド/プロセスあたりのメモリ消費量と並んで重要な特性値である．今後，環境を整備して測定を試みたい．

本提案方式は，現状ではノンプリエンプティブであるため，利用できる状況が限られる．Zackernel ではプリエンプティブマルチタスクと同様の使い勝手にするために，ループ中の1回1回の繰返しの際に他のタスクが起動可能かを判定するロジックを実装した．この方式をより使いやすくするために，プログラミング言語処理系に手を入れて，プログラム中のループにフックを挿入する事を考えている．また，Elixirにおいても，ループの代わりに用いられる再帰呼び出しや，EnumやFlow\cite{Flow}を用いたmap計算のようなまとまった処理を実行する際に，Zackernelと同様の仕組みを入れる方式が考えられる．

Zackernel はトリッキーなプログラミングになっていることから保守性が悪く，メモリリークの問題がまだ多く残っている．メモリリークが起こっている理由としては，通常の \Cpp プログラム同様，ガーベジコレクションされないという要因もありうるが，そのほかにも，Elixir のような関数型言語ではなく \Cpp で実装しているため，末尾再帰の最適化がなされないことから，コールバックする際に再帰呼び出しが深くなってしまう要因もありうる．

軽量コールバックスレッドについては，プロセス間通信の仕組みを実装することで，ようやく実用的なプログラムを書くことができる．もしそれが実現できた時には，軽量コールバックスレッドを用いるように Phoenix を実装しなおすことを考えている \cite{WSA2018-1}．また，Zackernel 並みに1スレッドあたりのメモリ消費量を抑えるような言語処理系の設計・実装を試みる．


\begin{figure*}[t]
\centering
\includegraphicS[width=0.6\linewidth]{memory-callback-process.png}
\caption{実験結果: 軽量コールバックスレッドとプロセスのメモリ消費量の比較(散布図)}
\ecaption{Results: Scatterplot of Comparison of Memory Size of Light-weight Callback Threads and Processes}
\label{fig:results}
\end{figure*}


